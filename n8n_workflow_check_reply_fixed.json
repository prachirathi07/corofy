{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "check-reply",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "3738666f-0b0e-4e5e-a83c-4809539e856c",
      "name": "Webhook",
      "webhookId": "d16a43c2-9668-4b65-86bb-a764b2ec4be5"
    },
    {
      "parameters": {
        "jsCode": "// Debug: Log what we received from webhook\nconst webhookData = $input.first().json;\n\nconsole.log('=== WEBHOOK DATA RECEIVED ===');\nconsole.log('Full webhook data:', JSON.stringify(webhookData, null, 2));\nconsole.log('Keys:', Object.keys(webhookData));\n\n// Extract gmail_thread_id - try different possible locations\nlet threadId = null;\n\n// Try direct access first (most common)\nif (webhookData.gmail_thread_id) {\n  threadId = webhookData.gmail_thread_id;\n  console.log('Found gmail_thread_id in root:', threadId);\n}\n// Try body.gmail_thread_id\nelse if (webhookData.body && webhookData.body.gmail_thread_id) {\n  threadId = webhookData.body.gmail_thread_id;\n  console.log('Found gmail_thread_id in body:', threadId);\n}\n// Try body as string (if n8n parsed it as string)\nelse if (webhookData.body && typeof webhookData.body === 'string') {\n  try {\n    const parsedBody = JSON.parse(webhookData.body);\n    threadId = parsedBody.gmail_thread_id;\n    console.log('Found gmail_thread_id in parsed body string:', threadId);\n  } catch (e) {\n    console.log('Could not parse body as JSON');\n  }\n}\n\nif (!threadId) {\n  console.error('ERROR: Could not find gmail_thread_id in webhook data');\n  return [{\n    json: {\n      error: 'gmail_thread_id not found in request',\n      has_reply: false,\n      received_data: webhookData\n    }\n  }];\n}\n\nconsole.log('Using thread ID:', threadId);\n\n// Pass thread ID to next node\nreturn [{\n  json: {\n    gmail_thread_id: threadId,\n    original_data: webhookData\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "extract-thread-id",
      "name": "Extract Thread ID"
    },
    {
      "parameters": {
        "resource": "thread",
        "operation": "get",
        "threadId": "={{ $json.gmail_thread_id }}",
        "simple": false,
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        448,
        0
      ],
      "id": "f128cd06-e09c-42fd-8172-e16d53428155",
      "name": "Get Thread",
      "webhookId": "f0ea23a2-4f88-4cec-ba40-97a187fe620f",
      "credentials": {
        "gmailOAuth2": {
          "id": "QLNjH08am02NUKOl",
          "name": "Gmail account fake.avi"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Logic to find the latest reply\nconst threadData = $input.first().json;\nconst messages = threadData.messages || [];\nconst threadId = threadData.id;\n\nconsole.log('=== PROCESSING THREAD ===');\nconsole.log('Thread ID:', threadId);\nconsole.log('Number of messages:', messages.length);\n\nlet hasReply = false;\nlet latestReply = null;\n\nif (messages && messages.length > 1) {\n  // Iterate backwards to find the latest message\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    \n    // Check headers to see who it is from\n    const headers = msg.payload?.headers || [];\n    let fromEmail = '';\n    let subject = '';\n    \n    headers.forEach(h => {\n      if (h.name === 'From') fromEmail = h.value;\n      if (h.name === 'Subject') subject = h.value;\n    });\n    \n    // Check labels - if it has 'INBOX' label, it's likely a reply\n    const labelIds = msg.labelIds || [];\n    \n    // Also check if it's not from 'me' (our own email)\n    // Gmail API typically marks our own messages differently\n    const isFromMe = labelIds.includes('SENT') || fromEmail.includes('me');\n    \n    // If it has INBOX label and is not from us, it's a reply\n    if (labelIds.includes('INBOX') && !isFromMe) {\n      hasReply = true;\n      \n      // Try to get full body text\n      let bodyText = msg.snippet || '';\n      \n      // Try to extract body from payload if available\n      if (msg.payload?.body?.data) {\n        // Base64 decode if needed\n        try {\n          bodyText = Buffer.from(msg.payload.body.data, 'base64').toString('utf-8');\n        } catch (e) {\n          // If that fails, try parts\n          if (msg.payload.parts) {\n            for (const part of msg.payload.parts) {\n              if (part.mimeType === 'text/plain' && part.body?.data) {\n                try {\n                  bodyText = Buffer.from(part.body.data, 'base64').toString('utf-8');\n                  break;\n                } catch (e) {\n                  console.log('Could not decode part body');\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      latestReply = {\n        body: bodyText || msg.snippet || '',\n        from: fromEmail,\n        subject: subject,\n        date: msg.internalDate,\n        messageId: msg.id\n      };\n      \n      console.log('Found reply:', {\n        from: fromEmail,\n        subject: subject,\n        hasBody: !!bodyText\n      });\n      \n      break;\n    }\n  }\n}\n\nif (!hasReply) {\n  console.log('No reply found in thread');\n}\n\n// Return response in format expected by Python code\nreturn [{\n  json: {\n    has_reply: hasReply,\n    body: latestReply?.body || '',\n    subject: latestReply?.subject || '',\n    from: latestReply?.from || '',\n    date: latestReply?.date || null,\n    message_id: latestReply?.messageId || null\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        0
      ],
      "id": "fa8ce8b1-ed11-4bc7-bc13-7599729e1bfe",
      "name": "Process Reply"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        896,
        0
      ],
      "id": "23298d33-ca52-4b41-b2df-52bc9c5802f1",
      "name": "Respond to Webhook"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract Thread ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Thread ID": {
      "main": [
        [
          {
            "node": "Get Thread",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Thread": {
      "main": [
        [
          {
            "node": "Process Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Reply": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "10e4e6c1eea9300223cd6b73408d4f00c50de7b03f854dae5b15fcc57988166b"
  }
}

